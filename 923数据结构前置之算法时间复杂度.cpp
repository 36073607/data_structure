#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
//程序运行的总时间主要和两点有关：
//1.执行每条语句的耗时     2.每条语句的执行频率

//eg:
int main()
{
	
	for (int i = 1; i <= n; i++)//频度为n+1次：判断并执行了n次，判断但不执行1次
	{
		for (int j = 1; j <= n; j++)//频度为n(n+1):外部for循环具体执行了n次，内部这个循环频度为n+1次，共n(n+1)次
		{
			c[i][j] = 0;//频度为n*n次
			for (int k = 1; k <= n; k++)//频度为n*n*(n+1)
			{
				c[i][j] = c[i][j] + a[i][k] * b[k][j];//频度为n*n*n
			}
		}
	}

	return 0;
}
//f(n) = n+1 + n(n+1) + n*n + n*n*(n+1) + n*n*n
//f(n) = 2n^3+3n^2+2n+1
//∴T(n) = O(n^3) -> 直接看最主要的语句执行次数

//最好时间复杂度：算法在最好情况下的时间复杂度
//最坏时间复杂度：算法在最坏情况下的时间复杂度
//平均时间复杂度：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计量的加权平均值

//对算法时间复杂度的度量，通常只讨论算法在最坏情况下的时间复杂度，即分析在最坏情况下，算法执行时间的上界


//常量阶示例

	x++;//频度为1
	s = 0;//频度为1

//f(n)=1+1=2
//T(n)=O(1)

for (int i = 0; i < 10000; i++)
{
	x++;
	s = 0;
}
//T(n)=O(1)


//线性阶示例
for (int i = 0; i < n; i++)
{
	x++;
	s = 0;
}
//T(n)=O(n)


//平方阶示例
x = 0;//频度为1
y = 0;//频度为1
for (int k = 1; k <= n; k++)//频度为n+1
{
	x++;//频度为n
}
for (int i = 1; i <= n; i++)//频度为n+1
{
	for (int j = 1; j <= n; j++)//频度为n*(n+1)
	{
		y++;//频度为n*n
	}
}
//T(n)=O(n^2)


//立方阶示例
x = 1;//频度为1
for (int i = 1; i <= n; i++)//频度为n
{
	for (int j = 1; j <= i; j++)//频度为(1+2+3+...+n)=n(1+n)/2
	{

		for (int k = 1; k <= j; k++)
		{
			x++;//频度为 1+[1+(1+2)]+[1+(1+2)+(1+2+3)]+...+n(n+1)/2 = 1+4+10+...+n(n+1)/2 = [n(n+1)(n+2)]/6
		}
	}

}
//T(n)=O(n^3)


//对数阶示例
for (int i = 1; i <= n; i *= 2)
{
	x++;
	s = 0;
}
//次数 1 2 3 4 t
// i   1 2 4 8 2^t-1
//∴2^t-1 > n
//t> log2(n)+1
//T(n)=O(log2(n))


//练习：
x = 2;
while (x < n / 2)
	x = 2 * x;
//次数  1    2    3    4    t
//x    2^2  2^3  2^4  2^5  2^t+1
// 2^t+1 = n/2
// t = log2(n)-2
//T(n)=O(log2(n))


int fun(int n)
{
	int i = 0, sum = 0;
	while (sum < n)
		sum += ++i;
	return i;
}
//次数 1  2  3  4      t
// i   1  2  3  4      t
//sum  1  3  6  10  t(t+1)/2
//∴t(t+1)/2=n
//t约等于sqrt(2n)
//T(n)=O(n^1/2)


x = 0;
while (n >= (x + 1)(x + 1))
	x = x + 1;
//T(n)=O(n^1/2)


int sum = 0;
for (int i = 1; i < n; i *= 2)//这个是主循环，它结束了则整个代码也结束
	for (int j = 0; j < i; j++)//j的生命周期就在内层循环内，主循环进行完一次后，j销毁，再次进入内层循环时，j=0
		sum++;
//次数      1    2    3    4    t
// i       2^0  2^1  2^2  2^3  2^t-1
//内层次数 2^0  2^1  2^2  2^3  2^t-1
//由主循环可知：t=log2(n)+1
//∴内层次数为：1+2+4+...+2^t-1 = (2^t)-1 = 2n-1     等比数列求和＋消元
//则：T(n)=O(n)


//小结：
//主循环才是整个程序终止的关键
//看清内层循环的限制条件是 < n(主循环的限制条件的参数) 还是 < i(主循环的变量)
//最内层循环往往是时间复杂度的主要因素
//遇到难题可以列表，设总次数为t，利用主循环写出t与限制条件n的关系式，再写出内层循环的总次数(关于t的表达式)，最后联立两个式子解得内层循环次数(关于n的表达式)，从而写出时间复杂度
//列表经验：
//次数
//i（主循环参数，最终需与主循环判断条件n列等式）   注意是变量的值
//循环次数j(第二层循环每次发生主循环后循环的总次数)    注意不是变量的值
//最内层循环次数k(最内层循环每次发生主循环后循环的总次数)    注意不是变量的值
